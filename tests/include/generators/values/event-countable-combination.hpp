/*
 * SPDX - FileCopyrightText: Â© 2025 Kyurenpoto <heal9179@gmail.com>
 *
 * SPDX - License - Identifier: MIT
 */

#pragma once

#include <array>
#include <ranges>

#include "generators/multi-index.hpp"
#include "generators/sequence-from-indice.hpp"

namespace Countable
{
    template <std::ranges::input_range Range>
    struct EventCountableSequence
    {
        consteval EventCountableSequence(Range indice) :
            EventCountableSequence{
                Util::SequenceFromIndice<Range>{
                    indice,
                },
            }
        {
        }

        template <typename EventCountable, size_t N>
        consteval std::array<EventCountable, N> value() const
        {
            return sequence.template value<EventCountable, N>(
                [](const size_t idx)
                {
                    return EventCountable::prototype();
                },
                []<typename T>(const T& x, const size_t idx)
                {
                    static constexpr std::array<EventCountable (EventCountable::*)() const, 3> EVENT_METHODS{
                        &EventCountable::pass,
                        &EventCountable::fail,
                        &EventCountable::skip,
                    };

                    return (x.*EVENT_METHODS[idx])();
                }
            );
        }

    private:
        consteval EventCountableSequence(Util::SequenceFromIndice<Range> sequence) :
            sequence{
                sequence,
            }
        {
        }

        Util::SequenceFromIndice<Range> sequence;
    };

    template <std::ranges::input_range Range>
    EventCountableSequence(Range) -> EventCountableSequence<Range>;

    /**
     * @brief Generates combinations of two EventCountable values for each index.
     *
     * @details Each pair selected from same EventCountable sequence.
     *
     * @tparam EventCountable
     * @tparam Ns
     */
    template <typename EventCountable, size_t... Ns>
    struct EventCountableDoubleValueCombination
    {
        /**
         * @brief The size of index range.
         *
         * @return constexpr size_t
         */
        static constexpr size_t size()
        {
            return COMBINATION_INDEX_LIMIT;
        }

        /**
         * @brief The first value of EventCountable pair for the given index.
         *
         * @tparam IDX
         * @return constexpr EventCountable
         */
        template <size_t IDX>
        constexpr EventCountable a() const
        {
            return SEQUENCE[INDICE[IDX][0]];
        }

        /**
         * @brief The second value of EventCountable pair for the given index.
         *
         * @tparam IDX
         * @return constexpr EventCountable
         */
        template <size_t IDX>
        constexpr EventCountable b() const
        {
            return SEQUENCE[INDICE[IDX][1]];
        }

    private:
        static constexpr size_t COMBINATION_INDEX_LIMIT = sizeof...(Ns);
        static constexpr size_t OP_VARIETY_LIMIT = 3;

        static constexpr auto INDICE = std::array{
            (Util::MultiIndex<Ns, COMBINATION_INDEX_LIMIT, COMBINATION_INDEX_LIMIT, OP_VARIETY_LIMIT>{}.value())...
        };
        static constexpr auto SEQUENCE = EventCountableSequence{
            INDICE
            | std::views::transform(
                [](const auto& x)
                {
                    return x[2];
                }
            )
        }.template value<EventCountable, COMBINATION_INDEX_LIMIT>();
    };

    /**
     * @brief Generates combinations of two EventCountable arrays for each index.
     *
     * @details Each pair selected from different EventCountable sequence.
     * Each element in the array is generated by dropping one operation from three operations.
     *
     * @tparam EventCountable
     * @tparam Ns
     */
    template <typename EventCountable, size_t... Ns>
    struct EventCountableSingleDropCombination
    {
        /**
         * @brief The first value of EventCountable array pair for the given index.
         *
         * @tparam IDX
         * @return constexpr std::array<EventCountable, 3>
         */
        template <size_t IDX>
        constexpr std::array<EventCountable, 3> a() const
        {
            return {
                SEQUENCES[0][0][INDICE[IDX][0]],
                SEQUENCES[0][1][INDICE[IDX][0]],
                SEQUENCES[0][2][INDICE[IDX][0]],
            };
        }

        /**
         * @brief The second value of EventCountable array pair for the given index.
         *
         * @tparam IDX
         * @return constexpr std::array<EventCountable, 3>
         */
        template <size_t IDX>
        constexpr std::array<EventCountable, 3> b() const
        {
            return {
                SEQUENCES[1][0][INDICE[IDX][0]],
                SEQUENCES[1][1][INDICE[IDX][0]],
                SEQUENCES[1][2][INDICE[IDX][0]],
            };
        }

    private:
        static constexpr size_t COMBINATION_INDEX_LIMIT = sizeof...(Ns);
        static constexpr size_t OP_VARIETY_LIMIT = 3;

        static constexpr auto INDICE = std::array{
            (Util::MultiIndex<Ns, COMBINATION_INDEX_LIMIT, OP_VARIETY_LIMIT - 1, OP_VARIETY_LIMIT - 1>{}.value())...
        };
        static constexpr auto SEQUENCES = std::array{
            std::array{
                EventCountableSequence{
                    INDICE
                        | std::views::transform(
                            [](const auto& x)
                            {
                                return (x[1] + 1) % OP_VARIETY_LIMIT;
                            }
                        ),
                }
                    .template value<EventCountable, COMBINATION_INDEX_LIMIT>(),
                EventCountableSequence{
                    INDICE
                        | std::views::transform(
                            [](const auto& x)
                            {
                                return (x[1] + 2) % OP_VARIETY_LIMIT;
                            }
                        ),
                }
                    .template value<EventCountable, COMBINATION_INDEX_LIMIT>(),
                EventCountableSequence{
                    INDICE
                        | std::views::transform(
                            [](const auto& x)
                            {
                                return x[1];
                            }
                        ),
                }
                    .template value<EventCountable, COMBINATION_INDEX_LIMIT>(),
            },
            std::array{
                EventCountableSequence{
                    INDICE
                        | std::views::transform(
                            [](const auto& x)
                            {
                                return (x[2] + 1) % OP_VARIETY_LIMIT;
                            }
                        ),
                }
                    .template value<EventCountable, COMBINATION_INDEX_LIMIT>(),
                EventCountableSequence{
                    INDICE
                        | std::views::transform(
                            [](const auto& x)
                            {
                                return (x[2] + 2) % OP_VARIETY_LIMIT;
                            }
                        ),
                }
                    .template value<EventCountable, COMBINATION_INDEX_LIMIT>(),
                EventCountableSequence{
                    INDICE
                        | std::views::transform(
                            [](const auto& x)
                            {
                                return x[2];
                            }
                        ),
                }
                    .template value<EventCountable, COMBINATION_INDEX_LIMIT>(),
            },
        };
    };
};
